import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

public class Quadtree {
	
	//
	public Controller controller = null;
	// the starting node
	Node root;
	
	// max depth that the tree can be
	int max_depth = 10;
	
	// I was thinking that this has a way of knowing if a place is free, !free, !Checked
	// if we are to do this we need to send a point every step and not just at the 
	// time of a hit
	boolean complete = true;
	
	// 
	public Quadtree(Controller con, int x1, int y1, int x2, int y2){
		controller = con;
		root = new Node(x1,y1,x2,y2);
		
		controller.window.panel_tree.painter = this;
		controller.window.panel_tree.setSize(root.x2 - root.x1, root.y2 - root.y1);
		//resize(root.x2 - root.x1, root.y2 - root.y1);
		
		set_point(200, 200);
		
		// a simple timer to repaint the tree
		Timer timer = new Timer();
		TimerTask myTask = new TimerTask() {
		    @Override
		    public void run() {
		    	controller.window.panel_tree.repaint();
		    }
		};
		timer.schedule(myTask, 2000, 2000);
	}
	
	public void set_point(int x, int y){
		set_point(0, root, x, y);
	}
	
	private void set_point(int depth, Node node, int x, int y){
		if (depth > max_depth) return;
		
		set_point(depth+1, node.split(x, y), x, y);
	}
	
	//
	private class Node {
		Node UL = null;
		Node UR = null;
		Node DL = null;
		Node DR = null;
		
		Node parent = null;
		
		int depth = 0;
		
		int x1 = 0;// top left point
		int y1 = 0;
		int x2 = 0;// bottom right point
		int y2 = 0;
		
		int hx = 0; // half x
		int hy = 0; // half y

		public Node split(int x, int y){
			UL = new Node(x1, y1, hx, hy);
			UR = new Node(hx, y1, x2, hy);
			DL = new Node(x1, hy, hx, y2);
			DR = new Node(hx, hy, x2, y2);
			
			if (x <= hx && y <= hy) return UL;
			if (x >= hx && y <= hy) return UR;
			if (x <= hx && y >= hy) return DL;
			if (x >= hx && y >= hy) return DR;
			
			// there has been a really big error if this returns
			return UL;
		}
		
		public Node(int x1, int y1, int x2, int y2){
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
			
			this.hx = (x1+x2)/2;
			this.hy = (y1+y2)/2;
		}
		
		public Node(Node parent, int x1, int y1, int x2, int y2){
			this.parent = parent;
			this.depth = parent.depth+1;
			
			this.x1 = x1;
			this.y1 = y1;
			this.x2 = x2;
			this.y2 = y2;
			
			this.hx = (x1+x2)/2;
			this.hy = (y1+y2)/2;
		}
		
	}
	
	
	public void paint(Graphics g){
		Graphics2D g2 = (Graphics2D) g;

		// draw all the nodes recursively
		draw_node(root, g2);
		
		g2.drawString(String.valueOf(controller.window.panel_tree.getWidth()), 5, 5);
		/*
		int rt_width = root.x2 - root.x1;
		int rt_height = root.y2 - root.y1;
		BufferedImage bf = new BufferedImage(rt_width, rt_height, BufferedImage.TYPE_INT_RGB);
		Graphics2D b_g2 = bf.createGraphics();
		
		// draw all the nodes recursively
		draw_node(root, b_g2);
		
		Graphics2D g2 = (Graphics2D) g;
		g2.drawImage(bf, 0, 0, controller.window.panel_tree.getWidth(), controller.window.panel_tree.getHeight(), null);
		
		b_g2.dispose();
		*/
	}
	private void draw_node(Node node, Graphics2D g2){
		// draw the current nodes outline
		g2.drawLine(node.x1, node.y1, node.x2, node.y1);// top
		g2.drawLine(node.x1, node.y2, node.x2, node.y2);// bottom
		g2.drawLine(node.x1, node.y1, node.x1, node.y2);// left
		g2.drawLine(node.x2, node.y1, node.x2, node.y2);// right
		
		if (node.UL != null) draw_node(node.UL, g2);
		if (node.UR != null) draw_node(node.UR, g2);
		if (node.DL != null) draw_node(node.DL, g2);
		if (node.DR != null) draw_node(node.DR, g2);
		
	}
	
}
